# -*- coding: utf-8 -*-
"""DL_Task1_FC.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18I-6nIehy5vOb3u5BBgW7fkjvesfxtdu

Train Model A: Fully Connected Layers

Below are the steps to perform image classification on the MNIST dataset using only fully connected layers in Google Colab:

We need to install the required libraries, such as TensorFlow and Keras, by running the following code in a code cell:
"""

!pip install tensorflow
!pip install keras

!pip install keras-applications

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from tensorflow import keras
import cv2

"""1. Load the MNIST dataset using Keras:"""

from keras.datasets import mnist
(X_train_FC, y_train_FC), (X_test_FC, y_test_FC) = mnist.load_data()

"""2. Preprocess the data by reshaping the image arrays and normalizing the pixel values:"""

X_train_FC = X_train_FC.reshape(-1, 784) / 255.0
X_test_FC = X_test_FC.reshape(-1, 784) / 255.0

"""3. One-hot encode the target labels:"""

from keras.utils import to_categorical
y_train_FC = to_categorical(y_train_FC, 10)
y_test_FC = to_categorical(y_test_FC, 10)

print("Training data shape: ", X_train_FC.shape)
print("Training labels shape: ", y_train_FC.shape)
print("Test data shape: ", X_test_FC.shape)
print("Test labels shape: ", y_test_FC.shape)

"""4. Define the model architecture using a sequential model and dense layers:"""

from keras.models import Sequential
from keras.layers import Dense

model_FC = Sequential()
model_FC.add(Dense(512, activation='relu', input_shape=(784,)))
model_FC.add(Dense(256, activation='relu'))
model_FC.add(Dense(10, activation='softmax'))
model_FC.summary()

"""5. Compile the model with a suitable loss function, optimizer, and metrics:"""

model_FC.compile(loss='categorical_crossentropy',
                 optimizer='adam',
                 metrics=['accuracy'])

"""6. Train the model using the fit method:"""

history = model_FC.fit(X_train_FC, y_train_FC, batch_size=128, epochs=10,
                       validation_data=(X_test_FC, y_test_FC))

"""7. Evaluate the model on the test data and show the results:"""

train_loss_FC, train_accuracy_FC = model_FC.evaluate(X_train_FC, y_train_FC)
test_loss_FC, test_accuracy_FC = model_FC.evaluate(X_test_FC, y_test_FC)
print('Train Loss:', train_loss_FC)
print('Train Accuracy:', train_accuracy_FC)
print('Test Loss:', test_loss_FC)
print('Test Accuracy:', test_accuracy_FC)

history.history['val_accuracy']

"""Graph Plotting to show performance of FC models """

fig = plt.figure(figsize=(15,4))

fig.add_subplot(121)
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.legend(['Training accuracy', 'Validation accuracy'])
plt.title('Training and validation accuracy: FC')
plt.xlabel('Epoch Number')
plt.ylabel('Accuracy')

fig.add_subplot(122)
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.legend(['Training loss', 'Validation loss'])
plt.title('Training and validation loss: FC')
plt.xlabel('Epoch Number')
plt.ylabel('Loss')
plt.show()

"""Confusion Matrix for FC"""

import itertools
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix
from sklearn.metrics import precision_score, recall_score, f1_score

# Get predictions
y_predict_FC = model_FC.predict(X_test_FC)
y_predict_FC = np.argmax(y_predict_FC, axis=1)

# Extract true class labels from one-hot encoded array
y_true_FC = np.argmax(y_test_FC, axis=1)

# Compute the confusion matrix
cm = confusion_matrix(y_true_FC, y_predict_FC)

# Calculate accuracy
accuracy = np.trace(cm) / float(np.sum(cm))

# Calculate precision
precision = precision_score(y_true_FC, y_predict_FC, average='macro')

# Calculate recall
recall = recall_score(y_true_FC, y_predict_FC, average='macro')

"""Print Performance Parameters"""

print("Accuracy: {:.4f}%".format(accuracy * 100))
print("Precision: {:.4f}%".format(precision * 100))
print("Recall: {:.4f}%".format(recall * 100))

# Plot the confusion matrix
plt.figure(figsize=(10, 10))
plt.imshow(cm, cmap=plt.cm.Blues)
plt.colorbar()
tick_marks = np.arange(10)
plt.xticks(tick_marks, [str(i) for i in range(10)], rotation=45)
plt.yticks(tick_marks, [str(i) for i in range(10)])
thresh = cm.max() / 2.
for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
    plt.text(j, i, cm[i, j],
             horizontalalignment="center",
             color="white" if cm[i, j] > thresh else "black")
plt.xlabel('Predicted label')
plt.ylabel('True label')
plt.title('Confusion Matrix: FC')
plt.show()